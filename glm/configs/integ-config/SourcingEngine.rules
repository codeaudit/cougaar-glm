;JESS example script
;(assert (request "63002L000"))


(set-reset-globals TRUE)


;(printout t "SRARSRASRA about to defclass expansion" crlf)
(defclass expansion org.cougaar.domain.planning.ldm.plan.ExpansionImpl)
(defclass failedallocation org.cougaar.domain.planning.ldm.plan.FailedAllocationImpl)

(defglobal 
 ?*DSrequirementGroups* = (new java.util.Vector) ;vector of hashtables
 ?*DSresourcePackages* = (new java.util.Vector)
 ?*DSRGs* = (new java.util.Hashtable) ;hastable from requirement to task
 ?*DST2RG* = (new java.util.Hashtable) ;from task to requirement
 ?*DSRPs* = (new java.util.Hashtable) ;hashtable from resource to subord

 ?*GSrequirementGroups* = (new java.util.Vector)
 ?*GSresourcePackages* = (new java.util.Vector)
 ?*GSRGs* = (new java.util.Hashtable)
 ?*GST2RG* = (new java.util.Hashtable) ;from task to requirement
 ?*GSRPs* = (new java.util.Hashtable)

 ?*NMrequirementGroups* = (new java.util.Vector)
 ?*NMresourcePackages* = (new java.util.Vector)
 ?*NMRGs* = (new java.util.Hashtable)
 ?*NMT2RG* = (new java.util.Hashtable) ;from task to requirement
 ?*NMRPs* = (new java.util.Hashtable)

 ?*oplan* = nil
 ;;this value is hours and is only good for testing. For the delivery it needs to be 0.
 ?*units* = 0 ;;//0 or 2 appears to work for maintenenace
              ;;// only 5 appears to work for AmmunitionTransportation
;this should be in a policy or something
?*toleranceMax* = 1.0
 )

(defrule loaded
  ?a <- (loaded)
=>
(if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then (printout t crlf "SRASRASRA loaded script " crlf))
 (retract ?a)
)


(defrule oplanMatch ""
 (declare (salience 1000))
 (oplan (OBJECT ?oplan))
=>
 (bind ?*oplan* ?oplan))

(deffunction showVal ($?args) 
 (printout t "SRASRASRA SHOWVAL: " ?args crlf)
 (return TRUE)
)

(deffunction loadOplan ()
  (bind ?oplan (new org.cougaar.domain.glm.oplan.Oplan (get-member org.cougaar.domain.glm.oplan.Oplan DEFAULT_FILE_NAME) (fetch _plugin) (call (call ?plugin jessGetLDM) getLdmFactory)))
  (return ?oplan)
  )
(deffunction getPreference (?task ?type)
 (bind ?pref1 (call ?task getPreferences))
 (bind ?retVal nil)
 (while (call ?pref1 hasMoreElements) 
  do
  (bind ?pref (call ?pref1 nextElement))
  (if (= (get-member org.cougaar.domain.planning.ldm.plan.AspectType ?type) (call ?pref getAspectType)) 
   then 
   (return ?pref)
   )  ; end if
  ) ; end while
  (return ?retVal)
)


(deffunction ofType(?type ?task) 
  ;type is DSMAINTENANCE or GSMAINTENANCE
    
(return (call org.cougaar.core.plugin.util.ExpanderHelper isOfType ?task (get-member org.cougaar.domain.planning.ldm.plan.Preposition  OFTYPE) ?type))

)


(deffunction orgType (?type ?org) 

;(printout t "SRASRASRA check orgType against " ?type " " (call ?org toString) crlf)

 (if (call ?org hasMaintenancePG) then
 	(bind ?mp (get (call ?org getMaintenancePG) level))
;         (printout t  " is orgtype " ?type " " ?mp "is it eq " (eq ?type ?mp) crlf)
       	(return (eq ?type ?mp))
   else 
 	(return (eq ?type "NM"))
)
)

(deffunction ofTypeMatchesLevel (?level ?task)
  ;;need to look at ofType typeidcode
  (if (call org.cougaar.core.plugin.util.ExpanderHelper isOfType ?task (get-member org.cougaar.domain.planning.ldm.plan.Preposition  OFTYPE) ?level)
      then 
    (return TRUE)
    else
     ;;if the type was NM, then if the task is not DS and not GS it's true
    (if (eq ?level "NM")
	then 
      (if (and (not (call org.cougaar.core.plugin.util.ExpanderHelper isOfType ?task (get-member org.cougaar.domain.planning.ldm.plan.Preposition  OFTYPE) "DSMaintenance"))
	       (not (call org.cougaar.core.plugin.util.ExpanderHelper isOfType ?task (get-member org.cougaar.domain.planning.ldm.plan.Preposition  OFTYPE) "GSMaintenance")))
	  then 
	(return TRUE)
	else 
	(return FALSE))
      else 
      (return FALSE)
      )
    )
  )

(deffunction makeTaskNeeds (?task )
  (bind ?mosquant (new java.util.Hashtable))
  ;(printout t "Making task needs for " (call ?task toString) crlf)
  (bind ?pref1  (call ?task getPreferences))
  ;(bind ?pref1 (call ?prefs iterator))
  (while (call ?pref1 hasMoreElements) 
    do
    (bind ?pref (call ?pref1 nextElement))
  
    (if (= (get-member org.cougaar.domain.planning.ldm.plan.AspectType TYPED_QUANTITY) 
	   (call ?pref getAspectType)) 
	then
      (bind ?av (get (get (get ?pref scoringFunction) best) aspectValue))
      (bind ?quantity (get ?av value))
      (bind ?asset (get ?av asset))
      (bind ?mos  (call com.sra.maintenance.MaintenancePlugInUtility getCSSCapability (call ?asset getCSSCapabilityPG) FALSE))
	 ;(printout t "NEEDS mos and quant " ?mos " " ?quantity crlf)
      (call ?mosquant put ?mos (new java.lang.Double ?quantity ))
      )					; endif
    )					; end while
  (return ?mosquant)
  )

(deffunction storeTaskInfo(?level ?task) 
  (bind ?mosquant (makeTaskNeeds  ?t1 ))
  (call (getRequirementGroups "NM") addElement ?mosquant)
  (call (getRGMapping "NM") put  ?mosquant ?t1)


)
;;for each task we are  sourcing, create hashtable. 
;; recreate it after each reset? 

;;want to separate on level of task and level of resource


(defrule matchNMTask "catch the tasks we are  interested in"
  (declare (salience 100))
  (task (OBJECT ?t1&~:(call  (fetch removedTasks) contains (call (call ?t1 getUID) toString)))
	(verb ?v1&:( ?v1 equals (get-member org.cougaar.domain.planning.ldm.plan.Verb SupportRequest)))
	(directObject ?do1)		;asset group?
	(prepositionalPhrases ?pp1&~:(ofType "DSMaintenance" ?t1)&~:(ofType "GSMaintenance" ?t1))	;Vector
	(preferences ?pref1)		;Vector
	(planElement nil)	   ;if nil 
	)
  
   
  =>
  (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then (printout t crlf "SRASRASRASRA  Caught a SupportRequest task "  crlf)
      (printout t (call ?t1 toString) crlf)
   ( printPreferences (call ?t1 getPreferences))
   )
  
  (bind ?mosquant (makeTaskNeeds  ?t1 ))
  (call (getRequirementGroups "NM") addElement ?mosquant)
  (call (getRGMapping "NM") put  ?mosquant ?t1)
  (assert (CLEARGA))
  )


(defrule matchFailedNMTask "catch the tasks we are  interested in"
  (declare (salience 100))
  ?a <- (changed ?taskId)
  (task (OBJECT ?t1&:(call (call (call ?t1 getUID) toString) equals (call ?taskId toString))&~:(call  (fetch removedTasks) contains (call (call ?t1 getUID) toString)))
	(verb ?v1&:( ?v1 equals (get-member org.cougaar.domain.planning.ldm.plan.Verb SupportRequest)))
	(directObject ?do1)		;asset group?
	(prepositionalPhrases ?pp1&~:(ofType "DSMaintenance" ?t1)&~:(ofType "GSMaintenance" ?t1))	;Vector
	(preferences ?pref1)		;Vector
	(planElement ?pe)	   
	
	)
  (failedallocation (OBJECT ?pe))
   (not (sourceFailed ?task)) ;we didn't just generate this one

  =>
  (retract ?a)
  (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then (printout t crlf "SRASRASRASRA  Reviewing a FAILEDALLOCATION SupportRequest task "  crlf)
      (printout t (call ?t1 toString) crlf)
   (printPreferences (call ?t1 getPreferences))
   )
  ;;;we're not really supposed to review FailedAllocations, but the quantities may be changed by the SourcingAllocator, so we are
  (bind ?mosquant (makeTaskNeeds  ?t1 ))
  (call (getRequirementGroups "NM") addElement ?mosquant)
  (call (getRGMapping "NM") put  ?mosquant ?t1)
  (assert (CLEARGA))
  (assert (wasFailed ?t1))
  )

(defrule matchDSTask "catch the tasks we are  interested in"
  (declare (salience 100))
  (task (OBJECT ?t1&~:(call (fetch removedTasks) contains (call (call ?t1 getUID) toString)))
	(verb ?v1&:(?v1 equals (get-member org.cougaar.domain.planning.ldm.plan.Verb SupportRequest)))
	(directObject ?do1)		;asset group?
	(prepositionalPhrases ?pp1&:(ofType "DSMaintenance" ?t1)) ;Vector
	(preferences ?pref1)		;Vector
	(planElement nil)		;if nil, expandable
	)

  =>
  (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING")	then	
     (printout t crlf "SRASRASRASRA  Caught a SupportRequest task "  crlf)
      (printout t (call ?t1 toString) crlf)
      (printPreferences (call ?t1 getPreferences))
      )
 
  (bind ?mosquant (makeTaskNeeds  ?t1 ))

  (bind ?newpp   (call ?t1 getPrepositionalPhrase (get-member org.cougaar.domain.planning.ldm.plan.Preposition FOR)) )
  (bind ?forOrg  (call ?newpp getIndirectObject))
  (call (getRequirementGroups "DS") addElement ?mosquant)
  (call (getT2RG "DS") put ?t1 ?mosquant)
  (call (getRGMapping "DS") put  ?mosquant ?t1)
  (assert (CLEARGA))
  
  )
(defrule matchFailedDSTask "catch the tasks we are  interested in"
  (declare (salience 100))
  ?a <- (changed ?taskId)
  
  (task (OBJECT ?t1&:(call (call (call ?t1 getUID) toString) equals (call ?taskId toString))&~:(call  (fetch removedTasks) contains (call (call ?t1 getUID) toString)))
	(verb ?v1&:( ?v1 equals (get-member org.cougaar.domain.planning.ldm.plan.Verb SupportRequest)))
	(directObject ?do1)		;asset group?
	(prepositionalPhrases ?pp1&:(ofType "DSMaintenance" ?t1))	;Vector
	(preferences ?pref1)		;Vector
	(planElement ?pe)	   
	
	)
  (failedallocation (OBJECT ?pe))
   (not (sourceFailed ?task)) ;we didn't just generate this one
   
  =>
  (retract ?a)
  (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then (printout t crlf "SRASRASRASRA  Reviewing a FAILEDALLOCATION SupportRequest task "  crlf)
      (printout t (call ?t1 toString) crlf)
   (printPreferences (call ?t1 getPreferences))
   )
  ;;;we're not really supposed to review FailedAllocations, but the quantities may be changed by the SourcingAllocator, so we are
  (bind ?mosquant (makeTaskNeeds  ?t1 ))
  (call (getRequirementGroups "DS") addElement ?mosquant)
  (call (getRGMapping "DS") put  ?mosquant ?t1)
  (assert (CLEARGA))
  (assert (wasFailed ?t1))
  )


(defrule matchGSTask "catch the tasks we are  interested in"
  (declare (salience 100))
  (task (OBJECT ?t1&~:(call (fetch removedTasks) contains (call (call ?t1 getUID) toString)))
	(verb ?v1&:(?v1 equals (get-member org.cougaar.domain.planning.ldm.plan.Verb SupportRequest)))
	(directObject ?do1)		;asset group?
	(prepositionalPhrases ?pp1&:(ofType "GSMaintenance" ?t1))	;Vector
	(preferences ?pref1)		;Vector
	(planElement nil)		;if nil, expandable
	)


  =>
 (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING")	then	
  (printout t crlf "SRASRASRASRA  Caught a SupportRequest task "  crlf)
   (printout t (call ?t1 toString) crlf)
   (printPreferences (call ?t1 getPreferences))
)

  (bind ?mosquant (makeTaskNeeds  ?t1))
(bind ?newpp   (call ?t1 getPrepositionalPhrase (get-member org.cougaar.domain.planning.ldm.plan.Preposition FOR)) )
  (bind ?forOrg  (call ?newpp getIndirectObject))

  (call (getRequirementGroups "GS") addElement ?mosquant)
   (call (getT2RG "GS") put ?t1 ?mosquant)
  (call (getRGMapping "GS") put  ?mosquant ?t1)
  (assert (CLEARGA))
  
  )


(defrule matchFailedGSTask "catch the tasks we are  interested in"
  (declare (salience 100))
  ?a <- (changed ?taskId)
  (task (OBJECT ?t1&:(call (call (call ?t1 getUID) toString) equals (call ?taskId toString))&~:(call  (fetch removedTasks) contains (call (call ?t1 getUID) toString)))
	(verb ?v1&:( ?v1 equals (get-member org.cougaar.domain.planning.ldm.plan.Verb SupportRequest)))
	(directObject ?do1)		;asset group?
	(prepositionalPhrases ?pp1&:(ofType "GSMaintenance" ?t1))	;Vector
	(preferences ?pref1)		;Vector
	(planElement ?pe)	   
	
	)
  (failedallocation (OBJECT ?pe))
   (not (sourceFailed ?task)) ;we didn't just generate this one

  =>
  (retract ?a)
  (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then (printout t crlf "SRASRASRASRA  Reviewing a FAILEDALLOCATION SupportRequest task "  crlf)
      (printout t (call ?t1 toString) crlf)
   (printPreferences (call ?t1 getPreferences))
   )
  ;;;we're not really supposed to review FailedAllocations, but the quantities may be changed by the SourcingAllocator, so we are
  (bind ?mosquant (makeTaskNeeds  ?t1 ))
  (call (getRequirementGroups "GS") addElement ?mosquant)
  (call (getRGMapping "GS") put  ?mosquant ?t1)
  (assert (CLEARGA))
  (assert (wasFailed ?t1))
  )

(defrule clearga
 ?x <- (CLEARGA)
 ?y <- (GADONE)
=>
 (retract ?y)
)



;;putting in a bad hack
;;if the unit is not available thru the end of the plan
;;don't source against it
(deffunction makeAssetCapabilities (?org)
  (bind ?oplan ?*oplan*)
  (if (eq ?oplan nil) then (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then 
      (printout t "NO OPLAN IN FORSCOM" crlf))
    (return nil))

 ;(bind ?thisOrg (call ?*oplan* getOrganizationObject ?uic))
 
  ;;(bind ?thruDate  (call ?oplan getEndTime))
  (bind ?avail (call (call ?org getRoleSchedule) getAvailableSchedule))
 (bind ?endDate (call ?avail getEndDate))
(bind ?tmpCalendar (new java.util.GregorianCalendar))
 (call ?tmpCalendar setTime (call ?*oplan* getCday))
  (call ?tmpCalendar add (get-member java.util.Calendar DATE) 181)
 (bind ?thruDate (call ?tmpCalendar getTime ))

;(if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then  (printout t; crlf "Available schedule of " ?org " " (call ?endDate toString) " oplan t;hrudate " (call ?thruDate toString) crlf)
;)
  (if (call ?thruDate after ?endDate) then (return nil))
  (bind ?mosquant (new java.util.Hashtable))
  (bind ?csspg (call ?org getCSSCapabilityPG))

  (bind ?resources (call ?csspg getCapabilities))
  (bind ?iterator (call ?resources iterator))
(if (call java.lang.Boolean getBoolean "DEBUG_CAPABILITIES") then
	(printout t crlf "Capabilities of " (call ?org toString) crlf))
  (while (call ?iterator hasNext)
    do (bind ?pair (call ?iterator next))
    (bind ?mos (call ?pair getType))
    (bind ?capacity (call ?pair getCapacity)) ;;a Capacity
	;;not checking units/duration
    (bind ?quantity (call ?capacity getQuantity)) ;;a Duration for maintenance tasks, mass for cargo and handling, volume for fuels
    (bind ?quant (call ?quantity getValue (call ?quantity getCommonUnit)))
    
(if (call java.lang.Boolean getBoolean "DEBUG_CAPABILITIES") then
  (printout t "HAS capability,  quantity " ?mos " "    ?quant  crlf))
    (call ?mosquant put ?mos  (new java.lang.Double ?quant) )
    );;end while
  (return ?mosquant)
  )

(defrule matchDSResource "catch the subordinates we can source "
  (subordinate (OBJECT ?t1&:(orgType "DSMaintenance" ?t1)))
  =>
 (if (call java.lang.Boolean getBoolean "DEBUG_RESOURCES") then
	(printout t "matched DS resource " (call ?t1 toString) crlf))
  (bind ?mosquant (makeAssetCapabilities ?t1))
  (if (neq ?mosquant nil) then 
    (call (getResourcePackages "DS") addElement ?mosquant)
    (call (getRPMapping "DS")  put  ?mosquant ?t1)
    )
  )

(defrule matchGSResource "catch the subordinates we can source "

  (subordinate (OBJECT ?t1&:(orgType "GSMaintenance" ?t1)))
	       

  =>
 (if (call java.lang.Boolean getBoolean "DEBUG_RESOURCES") then
	(printout t "matched GS resource " (call ?t1 toString) crlf))	
  (bind ?mosquant (makeAssetCapabilities ?t1))
   (if (neq ?mosquant nil) then 
     (call (getResourcePackages "GS") addElement ?mosquant)
     (call (getRPMapping "GS") put  ?mosquant ?t1)
     )
  )

(defrule matchNMResource "catch the subordinates we can source "
  (subordinate (OBJECT ?t1&:(orgType "NM" ?t1)))
  =>
 (if (call java.lang.Boolean getBoolean "DEBUG_RESOURCES") then
	(printout t "matched NM resource " (call ?t1 toString) crlf))
  (bind ?mosquant (makeAssetCapabilities ?t1))
   (if (neq ?mosquant nil) then 
     (call (getResourcePackages "NM") addElement ?mosquant)
     (call (getRPMapping "NM") put  ?mosquant ?t1)
    )
  )

;(import com.sra.sourcing)




(deffunction getT2RG (?level)
  (if (eq ?level "DS") then
    (return ?*DST2RG*)
    else
    (if (eq ?level "NM") then 
	(return ?*NMT2RG*) 
	else (return ?*GST2RG*)
	)
    )
)

(deffunction getRequirementGroups (?level)
  (if (eq ?level "DS") then
    (return ?*DSrequirementGroups*)
    else
    (if (eq ?level "NM") then 
	(return ?*NMrequirementGroups*) 
	else (return ?*GSrequirementGroups*)
	)
    )
)
(deffunction getResourcePackages (?level)
  (if (eq ?level "DS") then
    (return ?*DSresourcePackages*)
    else
    (if (eq ?level "NM") then 
	(return ?*NMresourcePackages*)
	else 
	(return ?*GSresourcePackages*)
	)
    )
)

(deffunction getRGMapping (?level)
  (if (eq ?level "DS") then
    (return ?*DSRGs*)
    else
    (if (eq ?level "NM") then
	(return ?*NMRGs*)
	else 
	(return ?*GSRGs*)
	)	
    )
)

(deffunction getRPMapping (?level)
  (if (eq ?level "DS") then
    (return ?*DSRPs*)
    else
    (if (eq ?level "NM") then
	(return ?*NMRPs*)
	else 
	(return ?*GSRPs*)
	)	
    )
)

(deffunction deleteRPs(?level  ?assets) 
  (bind ?resPak (getResourcePackages ?level))
;assets is a vector pf orgs
  (bind ?mapping (getRPMapping ?level)) ;hash from rp to org
  (bind ?orgs (call ?assets elements))
 (while (call ?orgs hasMoreElements)
   do (bind ?org (call ?orgs nextElement))
      (bind ?done FALSE)
      (bind ?keys (call ?mapping keys))
      (while (and (call ?keys hasMoreElements)
		  (not ?done))
	do (bind ?key (call ?keys nextElement))
	(if (eq (call ?mapping get ?key) ?org)
	    then (call ?resPak remove ?key)
	         (call ?mapping remove ?key)
	         (bind ?done TRUE))
      ) ; end while
      ) ; end while
)

(deffunction doSourcingInternal(?level)
  ;;need the data hased on type
  (bind ?reqGroups (getRequirementGroups ?level))
(if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
   (printout t "Sourcing " ?level crlf))
  (bind ?resPak (getResourcePackages ?level))
  (if (and (> (call ?reqGroups size) 0) (> (call ?resPak size) 0))
      then

    (bind ?toleranceBase 0.333)
(if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
 (printout t "Requirements " (call ?reqGroups toString) crlf)
(printout t "Resources " (call ?resPak toString) crlf))
    (bind ?GA (new com.sra.sourcing.SourcingProblem ?reqGroups ?resPak ?toleranceBase TRUE))
					;//run it
    (call ?GA defineAlleles)
    (bind ?pop (new com.sra.sourcing.GaaPopulation ?GA))
    (bind ?function  (get-member ?GA function))
    ;(printout t "Starting GA" crlf)
    (bind ?kickout 120)
    (bind ?relaxBase 20)
    (bind ?relaxLevel ?relaxBase)
    (bind ?counter 1)
    (while  (and (not (get-member ?pop exitFlag))
		 (< (get-member ?GA currentGeneration) ?kickout))
      do
      (while	(< (get-member ?GA currentGeneration) ?relaxLevel)
	do
	(call ?pop newGeneration)
	);;end while
		
      (if  (not (get-member ?pop exitFlag))
	  then 
	(bind ?counter (+ 1 ?counter))
	(bind ?newTolerance  (* ?toleranceBase ?counter) )
	(if (< ?newTolerance ?*toleranceMax*) 
	    then (call ?GA setToleranceFactor ?newTolerance)
(if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
  (printout t "SRASRASRA relaxing exitTolerance to " ?newTolerance crlf))
	    )
	)
	
      (bind ?relaxLevel (* ?relaxBase ?counter))
      )
  
    

    (bind ?best (get-member ?pop bestChrom))

(if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
  (printout t "result "  (call ?function getValue ?best)  " from "  ?best " at " (get-member ?GA currentGeneration) crlf))
					;//get results, are they good enough?
    (if    (get-member ?pop exitFlag) 
	then
					;//assert them
      (call (get-member ?GA alleleSet) decodeChrom ?best)
      (bind ?j (get-member ?GA genesNumber))
      (bind ?i 0)
      (bind ?assignments (new java.util.Hashtable))
      (while (< ?i ?j)
	do 
	;;RP(i) is given to RG(?group)
	(bind ?group (call ?GA getAlleleValue ?i))

	(if (> (call (getRequirementGroups ?level) size)  ?group) then
;(if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
;  (printout t "assigning RP " ?i " to group " ?group crlf))	    
	  ;;now we need to map back to task and asset
	  (bind ?task (call (getRGMapping ?level) get (call ?reqGroups  elementAt ?group)))
	  (bind ?asset (call (getRPMapping ?level) get (call ?resPak elementAt ?i)))
	  ;;for each of these assets (at least for now) remove them from rp's because otherwise they get resourced next time around? shouldn't the RFD make them unavailable?
	  ;;if I remove them from the resPak now, I mes sup the indexing

	  ;;store in a table
	  (bind ?rps (call ?assignments get ?task))
	  (if (eq ?rps nil) then
	    (bind ?rps (new java.util.Vector))
	    (call ?assignments put ?task ?rps))
	  (call ?rps addElement ?asset)
	
	  );;end if skipping the no assignment marker
	(bind ?i (+ 1 ?i))
	);;end while
      
      (bind ?assigns (call ?assignments keys))
;I think we only want the alert when there are no orgs available
;we can just return failed allocations for these tasks?
;except, this also tells that NO tasks are getting allocations, even if units are available
      (if (not (call ?assigns hasMoreElements)) then
	(noMatches)
	)
      (while (call ?assigns hasMoreElements)
	do
	(bind ?key (call ?assigns nextElement))
	(deleteRPs ?level  (call ?assignments get ?key)) ;key = task, assingments is asset
	(assert (assign ?key (call ?assignments get ?key)))
	)				; end while
      (return TRUE)
      else
      (if (> (call ?reqGroups size) 0) then 
	;;GA couldn't get a result
      (noMatches)
      else 
      (return TRUE)
      )
      )
    else 
;(if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
;  (printout t "SRASRASRA  RGs " (> (call ?reqGroups size) 0) " RPs " (> (c;all ?resPak size) 0) crlf))
    )
  )

(deffunction doSourcing ()
 ;//set up the GA
  ;(printout t "Running the GA" crlf)
;//need to be able to remove the reviewfailedallocations facts

(bind ?ds (doSourcingInternal "DS"))
(bind ?gs (doSourcingInternal "GS"))
(bind ?nm (doSourcingInternal "NM"))
  (return (and ?ds  ?gs  ?nm))
  
)


(deffunction noMatches ()
  "what if we run the GA and nothing comes out?"
  (printout t "Need alert, no units match requests or no units available" crlf)
  (return FALSE)
)

(defrule source "once we get all the needs, source them"
  (declare (salience -100))
  ;;what to match on?
   (subordinate (OBJECT ?s1))
   (task (OBJECT ?t1))
   ; no assigns waiting to be processed
   (not (assign ?t2 ?as))
   (not (GADONE))
   ?x <- (CLEARGA)
  =>
  (retract ?x)
  ;(printout t "SRASRASRA sourcing" crlf)
  (doSourcing)
  (assert (GADONE))
 (assert (retractReviews))
)

(defrule RetractingReviews ""
 ?b <- (retractReviews)
 ?a <- (reviewFailedAllocations ?level)
;there are no more reviewFailedAllocations facts
 (not (reviewFailedAllocations ?level2&:(neq ?level2 ?level)))
=>
 (retract ?a)
  (retract ?b))

(defrule RetractingReviewsFlag ""
?b <- (retractReviews)
?a <- (reviewFailedAllocations ?level)
;there are  more reviewFailedAllocations facts
  (reviewFailedAllocations ?level2&:(neq ?level2 ?level))
=>
 (retract ?a)
  )

(deffunction createReportTask (?org ?task ?verb )
  (bind ?plugin (fetch _plugin))
  (bind ?cof (call (call ?plugin jessGetLDM) getLdmFactory))
  (bind ?newTask (call ?cof newTask))
  ;; ensure this is a root level task
  (set ?newTask plan (call ?cof getRealityPlan))
					;set directObject to ?org
  (call ?newTask setDirectObject ?org)

  (set ?newTask source (call ?plugin jessGetClusterIdentifier))

					;// set prepositional phrase
  ;;need to set for as the unit we are being assigned to (COSCOM)
  ;;get the FOR from the ?task
  (bind ?prepPhrases (new java.util.Vector 2))
  (bind ?newpp   (call ?task getPrepositionalPhrase (get-member org.cougaar.domain.planning.ldm.plan.Preposition FOR)) )
   
  (bind ?toOrg (call (call ?newpp getIndirectObject) copy))
  (bind ?asspg  (call ?toOrg getAssignedPG))

  (bind ?newAssPG (call org.cougaar.domain.planning.ldm.asset.PropertyGroupFactory newAssignedPG))
  (call ?newAssPG setRelationship (get-member org.cougaar.domain.glm.plan.Relationship SUPERIOR))
  (call ?newAssPG setRoles (call ?asspg getRoles))
  (call ?toOrg setAssignedPG nil)
  (call ?toOrg setAssignedPG ?newAssPG)
  
  (bind ?newpp (call ?cof newPrepositionalPhrase))
  (call ?newpp setIndirectObject ?toOrg)
  (call ?newpp setPreposition (get-member org.cougaar.domain.planning.ldm.plan.Preposition FOR))
  (call ?prepPhrases addElement ?newpp)

  (bind ?newpp (call ?cof newPrepositionalPhrase))
  (call ?newpp setPreposition (get-member org.cougaar.domain.planning.ldm.plan.Preposition WITH))
					;//where to get ?oplan
  (bind ?oplan ?*oplan*)
  (if (eq ?oplan nil) then 
    (printout t "already creating tasks, but we have  no oplan" crlf)
    (bind ?oplan (loadOplan)))
  

  (call ?newpp setIndirectObject ?oplan)
  (call ?prepPhrases addElement ?newpp)
  (call ?newTask setPrepositionalPhrases (call ?prepPhrases elements))

					;// verb
  (call ?newTask setVerb (new org.cougaar.domain.planning.ldm.plan.Verb ?verb))
					;// schedule
  ;;need to get the start and end preferences out of the task
  (bind ?start (getPreference ?task START_TIME))

					;want end_time of RFD to be end of plan for ?toOrg but for now it's based on oplan
					;(bind ?thruDate  (call ?oplan getEndTime))
  (bind ?tmpCalendar (new java.util.GregorianCalendar))
  (call ?tmpCalendar setTime (call ?*oplan* getCday))
  (call ?tmpCalendar add (get-member java.util.Calendar DATE) 181)
  (bind ?thruDate (call ?tmpCalendar getTime ))
  (bind ?tav (new org.cougaar.domain.planning.ldm.plan.TimeAspectValue (get-member org.cougaar.domain.planning.ldm.plan.AspectType END_TIME) ?thruDate))
					
  (bind ?end (call ?cof newPreference (get-member org.cougaar.domain.planning.ldm.plan.AspectType END_TIME) (call org.cougaar.domain.planning.ldm.plan.ScoringFunction createStrictlyAtValue ?tav)))
  
  (bind ?preferenceVector (new java.util.Vector 2))
  (call ?preferenceVector addElement ?start)
  (call ?preferenceVector addElement ?end)
  (call ?newTask setPreferences (call ?preferenceVector elements ))
  ;;	//why weren't we doing this?
  ;; get ?org's capabilities and put them as the preferences
  (bind ?resources (call (call ?org getCSSCapabilityPG) getCapabilities))
  (bind ?iterator (call ?resources iterator))

  (bind ?theLDMF (call (call ?plugin jessGetLDM) getLdmFactory))
  (bind ?protoOrg (call ?theLDMF createPrototype "Organization" "Organization"))

  (while (call ?iterator hasNext)
    do 
    ;(if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then (printout t "RFD preferences "))
    (bind ?pair (call ?iterator next))
    (bind ?mos (call ?pair getType))
    (bind ?capacity (call ?pair getCapacity))
    ;;not checking units/duration
    (bind ?quantity (call ?capacity getQuantity))
    (bind ?quant (call ?quantity getValue (call ?quantity getCommonUnit))) ;;has to match what user used to generate task preferences
;(if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then (printout t ?mos " " ?quant " " crlf))
    (bind ?cssPG (call org.cougaar.domain.planning.ldm.asset.PropertyGroupFactory newCSSCapabilityPG))

    (bind ?collection (new java.util.ArrayList))
    (call ?collection add ?pair)
    (call ?cssPG setCapabilities ?collection)

    (bind ?mosAssetOrg (call ?theLDMF createInstance ?protoOrg ?mos))

    (call ?mosAssetOrg setPropertyGroup ?cssPG)
  
    (bind ?TQAV (new org.cougaar.domain.planning.ldm.plan.TypedQuantityAspectValue ?mosAssetOrg  ?quant))

    (call ?newTask addPreference (call ?cof newPreference (get-member org.cougaar.domain.planning.ldm.plan.AspectType TYPED_QUANTITY) (call org.cougaar.domain.planning.ldm.plan.ScoringFunction createPreferredAtValue ?TQAV (call (new java.lang.Double 1.0) doubleValue))))
    )
  
   (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then (printout t "FORSCOM GENERATING A RFD for " (call ?org toString) crlf)
  (printout t "Task preferences " )
 ( printPreferences (call ?newTask getPreferences)))
  (return ?newTask)
  )
  
  
(deffunction wireExpansion (?subTasks ?ldmf ?parentTask ?wf ?allocations ?new)
  (bind ?e (call ?subTasks elements))
  (if ?new then 
    (call ?wf setParentTask ?parentTask)
    (call ?wf setTasks ?e)
    ) ; end setting up subtasks
;;for some reason we need to do this twice?

 (bind ?e (call ?subTasks elements))
  (while (call ?e hasMoreElements)
    do
    (bind ?subTask (call ?e nextElement))
    (call ?subTask setWorkflow ?wf)
    ;(call ?wf addTask ?subTask)
    ) ; end while

;;//create and return expansion
  
  (if ?new then
    (bind ?estar (call com.sra.util.AuxQueryARA calculateOnEstimated ?wf (call ?allocations elements)))
    (bind ?exp (call ?ldmf createExpansion (call ?parentTask getPlan) ?parentTask ?wf ?estar))
    (definstance expansion ?exp)
    else
    (bind ?exp (call ?parentTask getPlanElement))
   ;;need an enumeration of allocations (but need all, not just the new ones)
;;to calculate the new estimated
    (bind ?estar (call com.sra.util.AuxQueryARA calculateOnAddedEstimateds ?wf (call ?allocations elements)))
    (call ?exp setEstimatedResult ?estar)
    ) ; end if new
 (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
   (printout t crlf crlf crlf "wire expansion is setting estar to " (call ?estar toString) "  " (call ?estar auxiliaryQuery (get-member org.cougaar.domain.planning.ldm.plan.AuxiliaryQueryType UNIT_SOURCED )) crlf))
 (return ?exp)
)

;;for ccreating the appropriate reportForDuty  tasks
(deffunction createReportTasks (?assignees ?task)
  (bind ?plugin (fetch _plugin))
  (bind ?cof  (call (call ?plugin jessGetLDM) getLdmFactory))
  (bind ?enum (call ?assignees elements))
  (bind ?subTasks (new java.util.Vector))
  (bind ?allocations (new java.util.Vector))
  (while (call ?enum hasMoreElements)
    do
    (bind ?asset (call ?enum nextElement))
    (bind ?rfdTask (createReportTask ?asset ?task "ReportForDuty"))

    (call ?subTasks addElement ?rfdTask)

    ;;allocate it also, then publish?
    (bind $?avs (create$))
    ;;use the start and end from the rfdTask, and the capability amounts from the ?asset
   (bind ?old_start (get (get (get (getPreference ?rfdTask START_TIME) scoringFunction) best) aspectValue))
   (bind ?start_copy (new org.cougaar.domain.planning.ldm.plan.TimeAspectValue (get-member org.cougaar.domain.planning.ldm.plan.AspectType START_TIME) (call ?old_start dateValue )))
    (bind $?avs (insert$ $?avs 1 (create$ ?start_copy)))
   (bind ?old_end (get (get (get (getPreference ?rfdTask END_TIME) scoringFunction) best) aspectValue))
(bind ?end_copy (new org.cougaar.domain.planning.ldm.plan.TimeAspectValue (get-member org.cougaar.domain.planning.ldm.plan.AspectType END_TIME) (call ?old_end dateValue)))
    (bind $?avs (insert$ $?avs 1 (create$ ?end_copy)))

    (bind ?resources (call (call ?asset getCSSCapabilityPG) getCapabilities))

    (bind ?iterator (call ?resources iterator))

(bind ?theLDMF (call (call ?plugin jessGetLDM) getLdmFactory))
(bind ?protoOrg (call ?theLDMF createPrototype "Organization" "Organization"))

    (while (call ?iterator hasNext)
      do (bind ?pair (call ?iterator next))
    (bind ?mos (call ?pair getType))
    (bind ?capacity (call ?pair getCapacity))
	;;not checking units/duration
    (bind ?quantity (call ?capacity getQuantity))
    (bind ?quant (call ?quantity getValue ?*units*)) ;;should be 0 but we're doing hours for testing

      (bind ?cssPG (call org.cougaar.domain.planning.ldm.asset.PropertyGroupFactory newCSSCapabilityPG))

      (bind ?collection (new java.util.ArrayList))
      (call ?collection add ?pair)
      (call ?cssPG setCapabilities ?collection)

      (bind ?mosAssetOrg (call ?theLDMF createInstance ?protoOrg ?mos))

      (call ?mosAssetOrg setPropertyGroup ?cssPG)
	    
      (bind ?TQAV (new org.cougaar.domain.planning.ldm.plan.TypedQuantityAspectValue ?mosAssetOrg  ?quant))
      (bind $?avs (insert$ $?avs 1 (create$ ?TQAV)))
      )
    (bind ?ar (call ?cof newAVAllocationResult 
		    (call (new java.lang.Double 1.0 ) doubleValue) 
		    TRUE 
		    ?avs))
    (call ?ar addAuxiliaryQueryInfo (get-member org.cougaar.domain.planning.ldm.plan.AuxiliaryQueryType UNIT_SOURCED) (call (call (call ?rfdTask getDirectObject) getItemIdentificationPG) getItemIdentification))

    (bind ?alloc (call ?cof createAllocation (get ?cof realityPlan) ?rfdTask (call ?rfdTask getDirectObject) ?ar (get-member org.cougaar.domain.planning.ldm.plan.Role BOGUS)))
    (call ?allocations addElement ?alloc)

    )
;;what if task already has a pe that is an expansion.
;; then we are adding RFD's
(if (eq (call ?task getWorkflow) nil) 
  then
;; wire exspansion
  (bind ?wf (call ?cof newWorkflow))
  (call ?wf setAllocationResultAggregator (new com.sra.util.AuxQueryARA))
  (bind ?expansion (wireExpansion ?subTasks ?cof ?task ?wf ?allocations TRUE))
;;this creates an estimated
  (bind ?estarResult2 (call ?plugin jessPublishAdd ?expansion))
   (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
     (printout t crlf crlf crlf "PUBLISH CHANGE OF ESTAR ON EXPANSION " ?estarResult2 crlf))
 else
  (bind ?wf (call ?task getWorkflow))
  ;;add subtasks to wf with expansions
  (bind ?expansion (wireExpansion ?subTasks ?cof ?task ?wf ?allocations FALSE))
;;this creates an estimated
 (bind ?estarResult (call ?plugin jessPublishChange ?expansion))
  (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
    (printout t crlf crlf crlf "PUBLISH CHANGE OF ESTAR ON EXPANSION " ?estarResult crlf))
) ;;end create/update expansion

  (bind ?subs (call ?subTasks elements))
  (while (call ?subs hasMoreElements)
    do
    (call (fetch _plugin) jessPublishAdd (call ?subs nextElement))
    )
;;publish everthing at once
; (printout t "published rfd tasks " ?subTasks " " )
 (bind ?allocs (call ?allocations elements))
 (while (call ?allocs hasMoreElements)
   do
  (bind ?alloc (call ?allocs nextElement))
  (bind ?result (call (fetch _plugin) jessPublishAdd ?alloc))
   ;(printout t crlf "PublishAdd of allocation "  ?result " for " (call ?task toString) crlf)
  (definstance allocation ?alloc)
   )

 ;;we need to manually update the allocation result on the expansion, because it won't be since the GRBPI  doesn't subscribe to expansions?

 (assert (sourced ?task))
 
 )

(deffunction updateSRAllocations (?wf) 
  (bind ?srTask (call ?wf getParentTask))
  (bind ?exp (call ?srTask getPlanElement))
  (bind ?subTasksE (call ?wf getTasks))
  (if (call ?subTasksE hasMoreElements) then (bind ?subTask (call ?subTaskE nextElement)))
  
  (printout t "In updateSRAllocations " (call ?srTask toString) crlf (call ?exp toString) crlf)
  ;;if the start date preference in the original SR is now earlier than the start date preference in the RFD, update the start date preference in all the RFD's in the workflow this task is in
  (bind ?srStartDate  (call (get (get (get (getPreference ?srTask START_TIME) scoringFunction) best) aspectValue) dateValue))
  (bind ?rfdStartDate (call (get (get (get (getPreference ?subTask START_TIME) scoringFunction) best) aspectValue) dateValue))

  (if (call ?srStartDate before ?rfdStartDate) then
    (printout t "Need to change the startDate on all the subtasks and publish change" crlf)

    )
  ;; if the total quanitity in the units RFD in response to the orginal support request is not enough to handle the request, source the diff
  ;;need to sum up all the available capabilities and compare to prefs

  (bind ?have (bag create have-bag))
  (bind ?subTasksE (call ?wf getTasks))
  (while (call ?subTaskE hasMoreElements) do
	 (bind ?subTask (call ?subTaskE nextElement))
	 (bind ?org (call ?subTask getDirectObject))
	 (bind ?csspg (call ?org getCSSCapabilityPG))
	 (bind ?resources (call ?csspg getCapabilities))
	 (bind ?iterator (call ?resources iterator))
	 (while (call ?iterator hasNext)
	   do (bind ?pair (call ?iterator next))
	   (bind ?mos (call ?pair getType))
	   (bind ?capacity (call ?pair getCapacity));;a Capacity
	   (bind ?quantity (call ?capacity getQuantity))
	   (bind ?quant (call ?quantity getValue (call ?quantity getCommonUnit)))
	   (if (neq nil (bag get ?have ?mos)) 
	       then 
	     (bag ?set ?have ?mos (+ (bag get ?have ?mos) ?quant))
	     else
	     (bag set ?have ?mos ?quant)
	     );;end if

	   )				; end capabilities
	 )				; end subtasks
 
  (bind ?prefsE (call ?srTask getPreferences))
 

  (while (call ?prefsE hasMoreElements) do
	 (bind ?pref (call ?prefsE nextElement))
	 (if (eq (call ?pref getAspectType) 
		 (get-member org.cougaar.domain.planning.ldm.plan.AspectType TYPED_QUANTITY))  then
	   (bind ?av (get (get (get ?pref scoringFunction) best) aspectValue))
	   (bind ?quantity (get ?av value));;these better be in common units
	   (bind ?asset (get ?av asset))
	   (bind ?mos  (call com.sra.maintenance.MaintenancePlugInUtility getCSSCapability (call ?asset getCSSCapabilityPG) FALSE))
	   (bind ?haveMOS (bag get ?have ?mos))
	   (if (eq ?haveMOS nil) then (bind ?haveMOS 0))
	   (if (> ?quantity ?haveMOS) then
	     (bind ?need (bag find need-bag))
	     ;;make the hastable we need for sourcng
	     (bind ?mosquant (new java.util.Hashtable))
	     (if (eq ?need nil) then (bind ?need (bag create need-bag)))
	     (bag set ?need ?mos (- ?quantity ?haveMOS))
	     (call ?mosquant put ?mos (new java.lang.Double (bag get ?need ?mos)))
	     );;end need
	   )				;end typed quantity
	 )				; end preferences

  (bind ?haveNeed (bag find need-bag))
  (if (neq ?haveNeed nil) then
    (printout t "SOURCE THE DELTA, add to the expansion " ?haveNeed crlf)
    ;;can we just do this out of line? how do we know where we are in the sourcing process? does it matter?

    ;;the orgs should all have the same level, so we can just use this one left from the loop
    (bind ?level (get (call ?org getMaintenancePG) level))

    (bind ?rgs (new java.util.Vector))
    (call ?rgs addElement ?mosquant)
    (bind ?rps (getResourcePackages ?level))
    (if (and (> (call ?rgs size) 0) (> (call ?rps size) 0))
	then
      (bind ?toleranceBase 0.33)
      (bind ?GA (new com.sra.sourcing.SourcingProblem ?rgs ?rps
		     ?toleranceBase TRUE))
					;//run it
      (call ?GA defineAlleles)
      (bind ?pop (new com.sra.sourcing.GaaPopulation ?GA))
      (bind ?function  (get-member ?GA function))
      (bind ?kickout 60)
      (bind ?relaxBase 20)
      (bind ?relaxLevel ?relaxBase)
      (bind ?counter 1)
      (while  (and (not (get-member ?pop exitFlag))
		   (< (get-member ?GA currentGeneration) ?kickout))
	do
	(while	(< (get-member ?GA currentGeneration) ?relaxLevel)
	  do
	  (call ?pop newGeneration)
	  );;end while
		
	(if  (not (get-member ?pop exitFlag))
	    then 
	  (bind ?counter (+ 1 ?counter))
	  (bind ?newTolerance  (* ?toleranceBase ?counter) )
	  (if (< ?newTolerance ?*toleranceMax*) 
	      then (call ?GA setToleranceFactor ?newTolerance)
	      (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
		(printout t "SRASRASRA relaxing exitTolerance to " 
			  ?newTolerance crlf))
	      )
	  )
	
	(bind ?relaxLevel (* ?relaxBase ?counter))
	)
  
    

      (bind ?best (get-member ?pop bestChrom))

      (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
	(printout t "result "  (call ?function getValue ?best)  " from "  ?best " at " (get-member ?GA currentGeneration) crlf))
				       ;//get results, are they good enough?
      (if    (get-member ?pop exitFlag) 
	  then
					;//assert them
	(call (get-member ?GA alleleSet) decodeChrom ?best)
	(bind ?j (get-member ?GA genesNumber))
	(bind ?i 0)
	(bind ?assignments (new java.util.Hashtable))
	;;store in a list, we only have one
	(bind ?given (new java.util.Vector))
	(while (< ?i ?j)
	  do 
	  ;;RP(i) is given to RG(?group)
	  (bind ?group (call ?GA getAlleleValue ?i))
	  ;;we only have one group for this
	  (if (eq ?group 0) then
	    ;;not being given to the null group
	    (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
	      (printout t "assigning RP " ?i " to group " ?group crlf))	    
	    ;;now we need to map back to task and asset
	    
	    (bind ?asset (call (getRPMapping ?level) get (call ?resPak elementAt ?i)))
	    ;;for each of these assets (at least for now) remove them from rp's because otherwise they get resourced next time around? shouldn't the RFD make them unavailable?
	    ;;if I remove them from the resPak now, I mes sup the indexing
	    (call ?given addElement ?asset)
	
	    );;end if skipping the no assignment marker
	  (bind ?i (+ 1 ?i))
	  );;end while
      
	
	
	
	  (deleteRPs ?level  ?given) ;?given is vector of assets
	  (assert (assign ?srTask ?given))
	  (return TRUE)
	else
	;;failed to get increment
	)
      else 
      (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
	(printout t "SRASRASRA  RGs " (> (call ?reqGroups size) 0) " RPs " (> (call ?resPak size) 0) crlf))
      ;;also fail to get increment here,
      )

    ;;NEED TO UPDATE THE EXPANSIONS
    );;end sourcing step
  (bag delete ?have)
  (bag delete ?need)
  )
;;we're going to make the ar on the RFD stale, if the original supportrequest changes
;;this will allow us to notice those and update, without having to look at every allocation we have ever made

(defrule watchAllocations "to see if the asset is gone or changes? (originally, but now...) check orginal supportrequests for changes"
  (allocation (OBJECT ?alloc)
	      (task ?task)
	      (stale TRUE)
	      )
=>
 (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
     (printout t "Stale Allocation " (call ?alloc toString) " " (call ?task toString)  crlf)
     )
 (bind ?wf (call ?task getWorkflow))
 (updateSRAllocations ?wf)
 (call ?alloc setStale FALSE)
)

(defrule assignToFailed 
  ?a <- (wasFailed ?task)
  (failedallocation (OBJECT ?alloc) (task ?task))
  (assign ?task ?assignees)
=>
 (retract ?a)
;;need to remove the failed allocation before we put on the new one
(bind ?result (call (fetch _plugin) jessPublishRemove ?alloc))
(undefinstance  ?alloc)
(if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
	;(printout t "PublishRemove of allocation " ?result crlf)
    ;(printout t "Failed Allocation for " (call ?task toString) " being removed to allow retrying sourcing" crlf)
    (printout t "Removing failedAllocation from " (call ?task toString)  crlf))
)

(defrule failedAllocations "to try again to source if we've matched orgs since?"
  (declare (salience 500))
  (reviewFailedAllocations ?level)

  (failedallocation (OBJECT ?alloc) (task ?task)
		    )
   (task   (OBJECT ?task&:(ofTypeMatchesLevel ?level ?task))
	   (planElement ?pe&~nil)
	   (verb ?v&:(?v equals (get-member org.cougaar.domain.planning.ldm.plan.Verb SupportRequest))))
  (not (sourceFailed ?task)) ;we didn't just generate this one
 
=>

;;if reviewFailedAllocations exists, it's because we matched organizations 
; and asserted it so we could retry sourcing
;;for now, we will remove the failed allocation, but later, we could just update it with new info?

;;we can publish remove this allocation, but how do we reasser the task?

 (bind ?cdate (call (call ?task getCommitmentDate) ?toString))
 (if (neq ?cdate nil) then 
	(if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
	(printout t "SRASRASRA task cdate is " ?cdate crlf))
	)

(if (call ?task beforeCommitment (new java.util.Date (call (fetch _plugin) currentTimeMillis))) then
  (bind ?result (call (fetch _plugin) jessPublishRemove ?alloc))
  (undefinstance  ?alloc)
  (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
    ;(printout t "PublishRemove of allocation " ?result crlf)
    ;(printout t "Failed Allocation for " (call ?task toString) " being removed to allow retrying sourcing" crlf)
    (printout t "Removing failedAllocation from " (call ?task toString) "to retry sourcing" crlf)

    )
  ;;this will make the task wait another cycle to be processed, while the change takes effect?
  ;;do I have to explicitly call this, or does the architecture handle it?
  ;;should only do this if we've removed the allocation
  ;(call (fetch _plugin) jessPublishChange (call ?alloc getTask))
  else 
  (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
    (printout t "Can't PublishRemove of allocation, not beforeCommitment "  crlf))
  )

)
(undefrule failedAllocations)

(deffunction arEqual (?ar1 ?ar2) 
  (bind ?result (call ?ar1 isEqual ?ar2))
  (if (not ?result) then 
    (return ?result))
       ;and the auxquery stuff is equa
  (bind ?auxEqual FALSE)
  (bind ?estarAux  (call ?ar2 auxiliaryQuery (get-member org.cougaar.domain.planning.ldm.plan.AuxiliaryQueryType UNIT_SOURCED )))
  (bind ?reparAux (call ?ar1 auxiliaryQuery (get-member org.cougaar.domain.planning.ldm.plan.AuxiliaryQueryType UNIT_SOURCED )))
    
  (if (neq ?estarAux nil) then 
    (bind ?auxEqual (call ?estarAux equals ?reparAux))
    else 
    (if (eq ?reparAux nil) 
	then (bind ?auxEqual TRUE)	; both nil
	    
	else (bind ?auxEqual FALSE)
	)				;one nil the other not
    )
 
  (return  ?auxEqual)
)

(deffunction printPreferences (?preferences)
  (while (call ?preferences hasMoreElements) do
	 (bind ?p (call ?preferences nextElement))
	 (if (eq (call ?p getAspectType) (get-member org.cougaar.domain.planning.ldm.plan.AspectType TYPED_QUANTITY))  then
      
	   (bind ?tav   (call (call (call ?p getScoringFunction) getBest) getAspectValue) )
	   (bind ?a (call ?tav getAsset)) 
	   (printout t "pref TYPED_QUANTITY = Asset: " 
		     (call com.sra.maintenance.MaintenancePlugInUtility getCSSCapability (call ?a getCSSCapabilityPG) FALSE) 
		     " Quantity: "  (call ?tav getValue) crlf)   
    
	   else 
		 (if (eq (call ?p getAspectType) (get-member org.cougaar.domain.planning.ldm.plan.AspectType COST)) then
		   (printout t "Pref COST = ")
		   (printout t (call  (call (call (call ?p getScoringFunction) getBest) getAspectValue) getValue)  crlf)
		   )
		 (if (eq (call ?p getAspectType) (get-member org.cougaar.domain.planning.ldm.plan.AspectType QUANTITY)) then
		   (printout t "Pref QUANTITY = ")
(printout t (call  (call (call (call ?p getScoringFunction) getBest) getAspectValue) getValue)  crlf)
		   )
		 (if (eq (call ?p getAspectType) (get-member org.cougaar.domain.planning.ldm.plan.AspectType START_TIME)) then
		   (printout t "Pref START_TIME = ")
(printout t (call (call (call (call (call ?p getScoringFunction) getBest) getAspectValue) dateValue) toString) crlf)
		   )
		 (if (eq (call ?p getAspectType) (get-member org.cougaar.domain.planning.ldm.plan.AspectType END_TIME)) then
		   (printout t "Pref END_TIME = ")
(printout t (call (call (call (call (call ?p getScoringFunction) getBest) getAspectValue) dateValue) toString) crlf)
		   )
		 
		 )
    
	   )
  )

(defrule RFDAllocations ""
  (allocation 
   (OBJECT ?alloc)
   (task ?task)
   (asset ?asset)
   (reportedResult ?rr&~nil&:(call ?rr isSuccess)))

  (task   (OBJECT ?task)
	  (verb ?v&:(eq ?v (get-member org.cougaar.domain.planning.ldm.plan.Verb ReportForDuty))))
  
  =>
  (bind ?repar (call ?alloc getReportedResult))
  (bind ?estar (call ?alloc getEstimatedResult))
  (bind ?plugin (fetch _plugin))
  (if  (neq  ?repar nil)
      then
  ;always set the auxQUery info on the repar because the ORGREPORTPLUGIN didn't
    (call ?repar addAuxiliaryQueryInfo (get-member org.cougaar.domain.planning.ldm.plan.AuxiliaryQueryType UNIT_SOURCED) (call (call ?asset getItemIdentificationPG) getItemIdentification) )
   
    (if (or (eq ?estar nil) (not (arEqual ?repar ?estar)))
	then
      (set ?alloc estimatedResult ?repar)
      (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
	(printout t "RFD Allocation changed, asserting updateExpansion task estimated is " (call ?estar toString) " task reported is " (call ?repar toString) crlf))
      (assert (updateExpansion (call ?alloc getTask) ?repar))
      (call ?plugin jessPublishChange ?alloc)
    
      (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
	(printout t "RFD Allocation (changed?) for " (call ?task toString)  crlf "reported "   )
	(printout t "Task preferences " )
       (printPreferences (call ?task getPreferences))
       (printout t crlf "allocation result " (call ?repar toString) crlf)
       (printout t (call ?repar auxiliaryQuery (get-member org.cougaar.domain.planning.ldm.plan.AuxiliaryQueryType UNIT_SOURCED )) crlf)
       )

      
      )
    )
  )


(defrule failedRFDAllocations ""
  (allocation 
   (OBJECT ?alloc)
   (reportedResult ?rr&~nil&~:(call ?rr isSuccess))
   (task ?task)
   (asset ?asset)
   )
   (task   (OBJECT ?task)
	   (verb ?v&:(eq ?v (get-member org.cougaar.domain.planning.ldm.plan.Verb ReportForDuty))))
=>
 ;;if the RFD fails, we need to redefinstance the org we had allocated it to
 ;;delete the allocation and change the task that had been allocated so it will be resourced?
;won't we end up just resourcing the same unit for the same requirement again?
;what if we don't change the task, but just report the failure. Then we can
;just let COSCOM change the task if it wants, but we keep trying to source it? will we keep trying to source it if it has a failed allocation on it? NO..we are looking for tasks with no allocation on them to source


 (definstance subordinate ?asset)
 (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
   (printout t "FAILED RFD Allocation  for " (call ?task toString)  crlf))
)

(defrule sourceNeed ""
  ?n <- (assign ?task ?assignees)
  
             
  =>
;;  (printout t "SRASRASRA Sourcing need " (call ?task getUID) " " ?assignees crlf)
  (bind ?plugin (fetch _plugin))
  (bind ?id (call ?plugin jessGetClusterIdentifier))
  (bind ?ldm (call ?plugin jessGetLDM))
  (bind ?cof (call (call ?plugin jessGetLDM) getLdmFactory))

 
 ;;need to also create the reportforduty tasks for the org
  (createReportTasks ?assignees ?task)
  (retract ?n)
;truy undefinstancing org, since dates aren't helping
 (bind ?orgs (call ?assignees elements))
(while (call ?orgs hasMoreElements) 
  do (bind ?org (call ?orgs nextElement))
  (undefinstance ?org)
  )
 				
  )

(defrule trackRemmovedTasks
?a <- (removed ?taskId)
=>
(call (fetch removedTasks) addElement (call ?taskId toString))
)

(defrule removeTasks
	(declare (salience 8000))
	?a <- (removed ?taskId)
	?b <- (task (OBJECT ?task&:(call (call (call ?task getUID) toString) equals (call ?taskId toString))))
=>
(if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
  (printout t "SOURCING ENGINE removing " ?taskId  " " (call  (call (get (get (get (getPreference ?task START_TIME) scoringFunction) best) aspectValue) dateValue) toString ) crlf)
	(printout t (call ?task toString) crlf)
	(printout t "removing task with PE of " (call ?task getPlanElement) crlf)
	(printPreferences (call ?task getPreferences)))

(call (fetch removedTasks) addElement (call ?taskId toString))
(retract ?b)
;we know they are about to do a reset, but retract this anyway in case they change the code
(retract ?a)
)



(defrule failedAllocation
   (declare (salience -100))
   (GADONE)
   (not (assign ?t1 ?assignees)) ;no assigns left
   (task (OBJECT ?task)
	 (verb ?v&:(?v equals (get-member org.cougaar.domain.planning.ldm.plan.Verb SupportRequest)))
	(preferences ?prefs) 
	(planElement nil)		;if nil, still unsourced?
	)
  (not (sourced ?task)) ;there isn't an allocation for this task
  (not (wasFailed ?task)) ;it wasn't already failed
=>
(if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
  (printout t "Failed to allocate an org to task " (call (call ?task getUID) toString) " " (call  (call (get (get (get (getPreference ?task START_TIME) scoringFunction) best) aspectValue) dateValue) toString ) crlf))
  (bind ?plugin (fetch _plugin))
  (bind ?id (call ?plugin jessGetClusterIdentifier))
  (bind ?ldm (call ?plugin jessGetLDM))
  (bind ?cof (call (call ?plugin jessGetLDM) getLdmFactory))
  
 ;change Enumeration to list
 (bind $?avs (create$))
  
 (bind ?prefs (call ?task getPreferences))
 (while (call ?prefs hasMoreElements)
	do	
	(bind ?pref (call ?prefs nextElement))

	(bind ?av (get (get (get ?pref  scoringFunction) best) aspectValue))
       (if (eq (call ?av getAspectType) 
	(get-member org.cougaar.domain.planning.ldm.plan.AspectType TYPED_QUANTITY)) then
	(bind ?newAV (new org.cougaar.domain.planning.ldm.plan.TypedQuantityAspectValue 
	      (call ?av getAsset) (call ?av getValue)))
	else
	(if (eq (call ?av getAspectType) 
	(get-member org.cougaar.domain.planning.ldm.plan.AspectType START_TIME)) then
	(bind ?newAV (new org.cougaar.domain.planning.ldm.plan.TimeAspectValue (get-member org.cougaar.domain.planning.ldm.plan.AspectType START_TIME) (call ?av dateValue)))
	else
	(if (eq (call ?av getAspectType) 
	(get-member org.cougaar.domain.planning.ldm.plan.AspectType END_TIME)) then
	(bind ?newAV (new org.cougaar.domain.planning.ldm.plan.TimeAspectValue 
	(get-member org.cougaar.domain.planning.ldm.plan.AspectType END_TIME) (call ?av dateValue)))
	else
	(bind ?newAV (new org.cougaar.domain.planning.ldm.plan.AspectValue (call ?av getAspectType) (call ?av getValue)))
		) ;end the end time
	) ;;end the start time aspect types
	)		 ;;END THE typed quant aspect types
     
	(bind $?avs (insert$  $?avs 1 (create$ ?newAV)))
	);end while

 (bind ?ar (call ?cof newAVAllocationResult (call (new java.lang.Double 1.0 ) doubleValue) FALSE  $?avs))
(bind ?alloc (call ?cof createFailedAllocation (get ?cof realityPlan) ?task  ?ar))
(bind ?result (call ?plugin jessPublishAdd ?alloc))
; (if (not ?result) then  (printout t "published Failed Allocation " ?alloc " got " ?result crlf))
;;would putting this back in prevent the ga run when all we have is a new failed allocation?
 (definstance failedallocation ?alloc)
 (assert (sourceFailed ?task))
)

(deffunction containsTask (?enum ?task)
 (while (call ?enum hasMoreElements)
   	 do (bind ?next  (call ?enum nextElement))
	 (if (eq (call ?next getUID) (call ?task getUID)) then 
	   (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
	     (printout t "expansion has task, update allocation result" crlf))
	   (return TRUE)))
 (return FALSE)
)
(defrule updateExpansions 
  "update the estar on the expansion that has this subtask in it's workflow"
					;because we just updated the one on the allocation for it
  ?f <- (updateExpansion ?subTask ?reparTask)
  (expansion (OBJECT ?e)
	     (workflow ?wf&:(containsTask (call ?wf getTasks) ?subTask)))
  =>
  (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
    (printout t "updateExpansions" crlf))
  (retract ?f)
;;I think I need to do the below, because this fact is being processed before the update on the subtask's allocation get's processed by the infrastructure.
  (bind ?newAggregatedAR (call ?wf aggregateAllocationResults))
  (bind ?repar (call ?e  getReportedResult))
  (bind ?estar (call ?e getEstimatedResult))
  (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
    (printout t "expansion repar " (call ?repar toString) " expansion  estar " (call ?estar toString) " task repar " (call ?reparTask toString)  " aggregatedAR " ?newAggregatedAR crlf ))
;;we are going to short circuit things here and use the aggregated result we just generated
  (bind ?plugin (fetch _plugin))
  (if  (neq  ?newAggregatedAR nil)
      then
    (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
      (printout t "SRASRASRA Have a reported result on the expansion" crlf))
    (if (or (eq ?estar nil) (not (arEqual ?newAggregatedAR ?estar)))
	then
      (set ?e estimatedResult ?newAggregatedAR)
      (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
	(printout t "Set the estimated on the expansion to the reported, pubklishing change " crlf))
      (bind ?changeResult (call ?plugin jessPublishChange ?e))
      (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
	(printout t ?changeResult crlf)
	(if (eq ?changeResult FALSE) then
	  (printout t "FALSE, what is commitment date of subtask? " (call (call ?subTask getCommitmentDate) toString ) crlf))
      )
      )
    ;;what happens if we publishchange anyway, why would we want to anyway?
    ;;(call ?plugin jessPublishChange ?e)

    (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING") then
      (printout t "EXPANSION (changed?) "  crlf "reported "   (call ?newAggregatedAR auxiliaryQuery (get-member org.cougaar.domain.planning.ldm.plan.AuxiliaryQueryType UNIT_SOURCED ))))
    )
  )


(defrule matchRemovedTask ""
  ?a <- (task (OBJECT ?t1&:(call (fetch removedTasks) contains (call (call ?t1 getUID) toString))))
  (not (removed ?taskid&:(eq (call ?taskid toString) (call (call ?t1 getUID) toString))))

  =>
  (if (call java.lang.Boolean getBoolean "DEBUG_SOURCING")	then	
     (printout t crlf "SRASRASRASRA  MATCHED ON A REMOVED TASK "  crlf)
      (printout t (call ?t1 toString) crlf)
      (printPreferences (call ?t1 getPreferences))
      )
 
  (retract ?a)
  )

(store removedTasks (new java.util.Vector))
 (assert
  (loaded)
  )
 ;(assert (ORGANIZATIONS ))

;(watch activations)
;(watch rules)
